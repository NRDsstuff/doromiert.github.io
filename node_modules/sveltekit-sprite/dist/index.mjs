import { readFileSync, writeFileSync } from 'fs';
import _merge from 'lodash.merge';
import { optimize } from 'svgo';
import { lstat, readdir, readFile } from 'fs/promises';
import * as path from 'path';

async function compiler({
  svgSource = "src/lib/sprite",
  symbolPrefix = "svg",
  stylePrefix = "svg-style",
  svgoOptions = {
    presetDefault: true
  }
} = {}) {
  const spriteSrcType = await lstat(svgSource);
  const visuallyHidden = 'style="border:0;clip:rect(0 0 0 0);height:auto;margin:0;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap"';
  let spriteString = "";
  if (spriteSrcType.isDirectory()) {
    let spriteFilesArray = await getSpriteFilesArray(svgSource);
    for (let { filePath, symbolId } of spriteFilesArray) {
      spriteString = spriteString + await getSymbol({ filePath, symbolId, symbolPrefix, stylePrefix, svgoOptions });
    }
    return `<svg ${visuallyHidden}>${spriteString}</svg>`;
  } else {
    spriteString = await optimizeSVG({
      svgoOptions: pluginsConstructor({
        filePath: svgSource,
        symbolId: symbolPrefix,
        stylePrefix,
        svgoOptions,
        singleFileSprite: true
      }),
      filePath: svgSource
    });
    return spriteString.replace(/<svg.*?>/is, `<svg ${visuallyHidden}>`);
  }
}
async function getSpriteFilesArray(filesPath, parentID) {
  const files = await readdir(filesPath);
  let results = [];
  for (let file of files) {
    const fullPath = path.join(filesPath, file);
    const fileInfo = await lstat(fullPath);
    const fileExtname = path.extname(file);
    const fileName = path.basename(file, fileExtname);
    const currentID = parentID ? parentID + "-" + fileName : fileName;
    if (fileInfo.isDirectory()) {
      const childFolder = await getSpriteFilesArray(fullPath, currentID);
      results = results.concat(childFolder);
    } else if (fileExtname === ".svg") {
      results.push({
        filePath: fullPath,
        symbolId: currentID
      });
    }
  }
  return results;
}
async function getSymbol({ filePath, symbolId, symbolPrefix, stylePrefix, svgoOptions }) {
  const readySvgString = await optimizeSVG({
    svgoOptions: pluginsConstructor({
      filePath,
      symbolId,
      stylePrefix,
      svgoOptions
    }),
    filePath
  });
  const rules = {
    regexp: /<svg.*?(viewBox.*?[',",`].*?[',",`]).*?>(.*?)<\/svg>/is,
    string: `<symbol id="${symbolPrefix + "--" + symbolId}" $1>$2</symbol>`
  };
  return readySvgString.replace(rules.regexp, rules.string);
}
async function optimizeSVG({
  filePath,
  svgoOptions
}) {
  const rawSvgString = await readFile(filePath, "utf-8");
  const readySvgString = optimize(rawSvgString, svgoOptions);
  function checkForSVGOError(obj) {
    return typeof obj === "object" && obj !== null && !("data" in obj);
  }
  if (checkForSVGOError(readySvgString)) {
    console.error("SVGO run error:", readySvgString);
    throw new Error("SVGO run error");
  }
  return readySvgString.data;
}
const pluginsCache = {
  svgoOptions: {}
};
function pluginsConstructor({
  filePath,
  symbolId,
  stylePrefix,
  svgoOptions,
  singleFileSprite = false
}) {
  const prefixIdsPlugin = {
    name: "prefixIds",
    params: {
      prefix: stylePrefix + "--" + symbolId
    }
  };
  if (pluginsCache.svgoOptions?.plugins) {
    let plugin = pluginsCache.svgoOptions?.plugins?.find((plugin2) => {
      return typeof plugin2 === "object" && plugin2.name === "prefixIds";
    });
    if (typeof plugin === "object") {
      plugin = _merge(plugin, prefixIdsPlugin);
    }
    pluginsCache.svgoOptions.path = filePath;
  } else {
    svgoOptions.path = filePath;
    const defaultPreset = {
      name: "preset-default",
      params: {
        overrides: {
          cleanupIDs: {
            remove: false,
            minify: false
          }
        }
      }
    };
    if (!singleFileSprite && defaultPreset?.params?.overrides) {
      defaultPreset.params.overrides.removeViewBox = false;
    }
    let defaultConfigFound = false;
    let prefixIdsConfigFound = false;
    svgoOptions?.plugins?.forEach((plugin) => {
      if (typeof plugin === "object") {
        if (plugin.name === "preset-default") {
          defaultConfigFound = true;
          plugin.params = _merge(plugin.params, defaultPreset.params);
        }
        if (plugin.name === "prefixIds" && !singleFileSprite) {
          prefixIdsConfigFound = true;
          plugin.params = _merge(plugin.params, prefixIdsPlugin.params);
        }
      } else if (plugin === "preset-default") {
        defaultConfigFound = true;
        plugin = defaultPreset;
      } else if (plugin === "prefixIds" && !singleFileSprite) {
        prefixIdsConfigFound = true;
        plugin = prefixIdsPlugin;
      }
    });
    if (!defaultConfigFound && svgoOptions.presetDefault) {
      if (svgoOptions.plugins) {
        svgoOptions.plugins.push(defaultPreset);
      } else {
        svgoOptions.plugins = [defaultPreset];
      }
    }
    if (!prefixIdsConfigFound && !singleFileSprite) {
      if (svgoOptions.plugins) {
        svgoOptions.plugins.push(prefixIdsPlugin);
      } else {
        svgoOptions.plugins = [prefixIdsPlugin];
      }
    }
    pluginsCache.svgoOptions = svgoOptions;
  }
  console.dir(svgoOptions, { depth: null });
  return pluginsCache.svgoOptions;
}

function sveltekitSprite({
  injectLabel = "%vite.plugin.sprite%",
  svgSource,
  symbolPrefix,
  stylePrefix,
  svgoOptions
} = {}) {
  const appTemplate = readFileSync("src/app.html", "utf-8");
  return {
    name: "sveltekit-sprite",
    async buildStart() {
      const filesString = await compiler({
        svgSource,
        symbolPrefix,
        stylePrefix,
        svgoOptions
      });
      writeFileSync("src/app.html", appTemplate.replace(injectLabel, filesString));
    },
    async closeBundle() {
      writeFileSync("src/app.html", appTemplate);
    }
  };
}

export { sveltekitSprite };
